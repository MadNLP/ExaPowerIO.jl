var documenterSearchIndex = {"docs":
[{"location":"dev/#Developer-Documentation","page":"Developer Docs","title":"Developer Documentation","text":"","category":"section"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"This documentation covers how to:","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"Run the projects test suite\nRun the projets benchmarks\nUpdate and build documentation of ExaPowerIO","category":"page"},{"location":"dev/#Test-suite","page":"Developer Docs","title":"Test suite","text":"","category":"section"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"ExaPowerIO's test suite can be run with the following command:","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"julia --project=. -e 'using Pkg; Pkg.test(\"ExaPowerIO\")'","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"The tests compare output from parsing with PowerModels.jl. We realize this is suboptimal, and would encourage PR's changing this.","category":"page"},{"location":"dev/#Benchmarks","page":"Developer Docs","title":"Benchmarks","text":"","category":"section"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"ExaPowerIO's benchmarking suite can be run with the following command:","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"julia --project=benchmark benchmark/runbenchmarks.jl","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"Additionally, there are three available flags which can be passed to the benchmarking script:","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"--compare can be passed to output a comparison with PowerModels.jl's parser\n--intermediate can be passed to output the timing of the two stages of the parser (text -> struct, struct -> named tuple if applicable)\n--num-samples <k> or -n <k> can be passed to set the number of samples taken of each case in the benchmark. The default value is 10.","category":"page"},{"location":"dev/#Documentation","page":"Developer Docs","title":"Documentation","text":"","category":"section"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"ExaPowerIO uses Documenter.jl for its documentation. To build and deploy the documentation locally:","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"cd docs\njulia --project -e 'include(\"make.jl\"); using LiveServer; serve(dir=\"build\")'","category":"page"},{"location":"dev/","page":"Developer Docs","title":"Developer Docs","text":"The documentation should then be visible at localhost:8000.","category":"page"},{"location":"user/#User-Documentation","page":"User Docs","title":"User Documentation","text":"","category":"section"},{"location":"user/","page":"User Docs","title":"User Docs","text":"ExaPowerIO exports three functions:","category":"page"},{"location":"user/#ExaPowerIO.parse_pglib","page":"User Docs","title":"ExaPowerIO.parse_pglib","text":"parse_pglib(\n    ::Type{T},\n    dataset_query :: String,\n    datadir :: String;\n    out_type=Data{T}\n)\n\nSearches the PGLib database for dataset_query, and errors if there is not exactly 1 result. Otherwise, the matching file is downloaded and parsed to return a value of type out_type.\n\nEach value will be parsed as a ::Type{T}.\n\nCurrently, out_type can only be Data{T}, or NamedTuple.\n\nThe result will be cached to data_dir, which will be created if it does not exist.\n\n\n\n\n\n","category":"function"},{"location":"user/#ExaPowerIO.parse_file","page":"User Docs","title":"ExaPowerIO.parse_file","text":"parse_file(\n    ::Type{T},\n    fname :: String;\n    datadir=nothing,\n    out_type=Data{T}\n)\n\nParses the Matpower file specified by fname, and returns a value of type out_type.\n\nEach value will be parsed as a ::Type{T}.\n\nCurrently, out_type can only be Data{T}, or NamedTuple.\n\nThe result will be cached to data_dir, which will be created if it does not exist.\n\n\n\n\n\n","category":"function"},{"location":"user/#ExaPowerIO.struct_to_nt","page":"User Docs","title":"ExaPowerIO.struct_to_nt","text":"struct_to_nt(data :: T) :: NamedTuple where T\n\nThis is a general purpose function for converting structs to named tuples.\n\nIt is used internally when out_type=NamedTuple is passed to parse_pglib or parse_file, and is more expensive than the actual parsing in both cases.\n\nWe export this function for those wishing to compare the performance of out_type=ExaPowerIO.Data with out_type=NamedTuple, as well as benchmarking reasons.\n\n\n\n\n\n","category":"function"},{"location":"user/","page":"User Docs","title":"User Docs","text":"The default value for the out_type parameter of both parse_pglib and parse_file is ExaPowerIO.Data:","category":"page"},{"location":"user/#ExaPowerIO.Data","page":"User Docs","title":"ExaPowerIO.Data","text":"struct Data{T <: Real}\n    version :: String\n    baseMVA :: T\n    bus :: Vector{BusData{T}}\n    gen :: Vector{GenData{T}}\n    branch :: Vector{BranchData{T}}\n    storage :: Vector{StorageData{T}}\n    ratea :: Vector{T}\n    arc :: Vector{Tuple{Int, Int, Int}}\n    ref_buses :: Vector{Int}\nend\n\nversion, baseMVA, bus, gen, branch, and storage all corespond to members of the mpc object created by a matpower file. Their fields correspond exactly with the columns of the relevant mpc member.\n\narc, ratea, and ref_buses are convenience vectors constructed using the following:\n\ndata = parse_file(T, fname; out_type=ExaPowerIO.Data)\narc_from = [(i, b.fbus, b.tbus) for (i, b) in enumerate(data.branch)]\narc_to = [(i, b.tbus, b.fbus) for (i, b) in enumerate(data.branch)]\narc = [arc_from; arc_to]\nratea = [branch[l].ratea for (l, _, _) in arc]\nref_buses = filter(i -> (bus[i]).type != 3, 1:length(Data.bus))\n\n\n\n\n\n","category":"type"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of ExaPowerIO.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DICLAIMER: ExaPowerIO is in active development. There may be missing features, documentation, or other issues. If you experience any of these, please open Issues, or Pull Requests","category":"page"},{"location":"#What-does-ExaPowerIO-do?","page":"Introduction","title":"What does ExaPowerIO do?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ExaPowerIO was created with the goal of being a low-scope IO package for working with the Matpower File Format. Currently, ExaPowerIO currently only supports input (parsing) operations. ","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you are interested in trying ExaPowerIO, please see the Usage Documentation for information on using the functions / structs exported by ExaPowerIO.","category":"page"},{"location":"#Contributing","page":"Introduction","title":"Contributing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you wish to contribute to ExaPowerIO, please see the Developer Documentation for information on project structure, as well as running benchmarks / tests.","category":"page"},{"location":"#Alternatives","page":"Introduction","title":"Alternatives","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main alternative to ExaPowerIO is PowerModels.jl, a monolithic repository which:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"parses and processes Matpower as well as PTI files\nexports formulations for various ACOPF problems\nincludes tools to help solve these problems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Developers wishing to utilize only 1 or 2 of these utilities may find PowerModels bloated.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ExaPowerIO.jl due to its focused nature has superior performance to PowerModels. As seen, ExaPowerIO outperforms PowerModels by a factor of almost 2 in both allocation and timing.","category":"page"}]
}
